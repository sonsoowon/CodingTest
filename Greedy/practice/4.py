"""
3-4. 1이 될 때까지
임의의 수 N이 1이 될 때까지 두 연산 중 하나를 반복적으로 선택하여 수행한다.
1. N에서 1을 뺀다
2. N을 K로 나눈다. (N이 K로 나누어떨어질 때만 수행 가능)
N을 1이 될 때까지 수행하는 연산의 최소 횟수를 구하시오.

INPUT
N K

OUTPUT
최소 횟수


풀이
K로 나누는 연산을 최대한 많이 수행해야 최소한의 횟수로 N을 1로 만들 수 있다.

N이 1이 될 때까지 다음을 반복한다
1. N을 K로 나눌 수 없을 경우 1번 연산을 진행한다.
2. N을 K로 나눌 수 있을 경우 2번 연산을 진행한다.


* 풀이의 타당성
N == M * K (1 <= M) 인 N에 대하여 2번 연산을 수행한 결과는 N // K, 즉 N - M * (K - 1) 이다.
이때, 1 <= M * (K - 1) 이므로 1을 빼는 것보다 더 큰 폭으로 N이 감소한다.
따라서 2번 연산을 최대한 많이 수행해야한다.

만약 1번 연산이 'N에서 X (1 <= X)를 뺀다' 였다면
1) N을 1로 만들 수 없는 경우와 2) 2번 연산을 수행하는 조건을 추가해
더 복잡한 풀이를 진행해야할 것이다.


시간복잡도
첫번째 풀이는 연산의 횟수만큼 반복문이 실행된다면,
두번째 풀이는 훨씬 적은 반복 횟수로 결과를 구할 수 있다.
"""


N, K = map(int, input().split())


def solution(N, K):
    cnt = 0
    while N > 1:
        N = N // K if N % K == 0 else N - 1
        cnt += 1

    return cnt


def more_efficient(N, K):
    cnt = 0

    # N이 K보다 작아 1번 연산만 수행해야할 때까지 반복문 실행
    while N >= K:
        # 2번 연산을 수행할 수 있을 때까지 1을 뺀다
        target = (N // K) * K
        cnt += (N - target)
        N = target

        # 2번 연산 수행
        N //= K
        cnt += 1

    # 2번 연산을 최대한 수행한 후 나머지 수에 대해 1번 연산만 수행
    cnt += (N - 1)

    return cnt


print(more_efficient(N, K))

